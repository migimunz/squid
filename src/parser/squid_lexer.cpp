#include "squid_lexer.hpp"

namespace squid
{

squid_lexer::squid_lexer()
	:lexer(),
	 space_indent("    "),
	 indent_level(0)
{
	init();
}

squid_lexer::squid_lexer(const str_iter &text)
	:lexer(text),
	 space_indent("    "),
	 indent_level(0)
{
	init();
}

squid_lexer::~squid_lexer()
{
}

void squid_lexer::init()
{
	register_token(INVALID, 	match_invalid, 		"INVALID TOKEN",	false);
	register_token(END_OF_TEXT, match_end_of_text, 	"END_OF_TEXT",		true);
	register_token(WHITESPACE, 	match_whitespace, 	"WHITESPACE",		true);
	register_token(PLUS, 		match_plus, 		"'+'", 				true);
	register_token(MINUS,		match_minus, 		"'-'", 				true);
	register_token(MULTIPLY,	match_multiply, 	"'*'", 				true);
	register_token(DIVIDE,		match_divide, 		"'/'", 				true);
	register_token(MATCH,		match_match, 		"'='", 				true);
	register_token(IDENTIFIER, 	match_identifier, 	"IDENTIFIER", 		true);
	/**
	 * INDENT and DEDENT are never matched in text, only
	 * generated by the lexer when matching INDENT FRAGMENT
	 */
	register_token(INDENT_FRAG, match_indent_frag, 	"INDENT FRAGMENT",	false);
	register_token(INDENT,		match_always_fail,	"INDENT",			false);
	register_token(DEDENT,		match_always_fail,	"DEDENT",			false);
}

int squid_lexer::compute_indent_level(str_iter iter, str_iter end)
{
	int level = 0;
	while(iter.valid() && iter <= end)
	{
		iter = iter.match(space_indent) | iter.match("\t");
		if(iter.valid())
			level++;
		else
			report_warning("Malformed indentation detected", get_position());
	}
	return level;
}

void squid_lexer::transform_token(token &tok)
{
	if(tok.type == INDENT_FRAG)
	{
		int level = compute_indent_level(tok.text.get_start_iter(), tok.text.get_end_iter());
		int new_level = level - indent_level;

	}
}

void squid_lexer::consume_indent_token(token_type type)
{
	if(!tokens_ahead.empty())
	{
		if(tokens_ahead.front().type == type)
			throw "FIXME";
	}
}


}