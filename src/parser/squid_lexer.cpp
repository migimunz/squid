#include "squid_lexer.hpp"

namespace squid
{

squid_lexer::squid_lexer(const str_iter &iter)
	:lexer_base(iter)
{
}

// void squid_lexer::init()
// {
// 	register_token(INVALID, 	match_invalid, 		"INVALID TOKEN",	false);
// 	register_token(END_OF_TEXT, match_end_of_text, 	"END_OF_TEXT",		true);
// 	register_token(WHITESPACE, 	match_whitespace, 	"WHITESPACE",		true);
// 	/** OPERATORS AND SYMBOLS **/
// 	register_token(ARROW, 		match_arrow, 		"'->'", 			true);
// 	register_token(PLUS, 		match_plus, 		"'+'", 				true);
// 	register_token(MINUS,		match_minus, 		"'-'", 				true);
// 	register_token(MULTIPLY,	match_multiply, 	"'*'", 				true);
// 	register_token(DIVIDE,		match_divide, 		"'/'", 				true);
// 	register_token(MATCH,		match_match, 		"'='", 				true);
// 	register_token(PAREN_OPEN,	match_paren_open,	"'('", 				true);
// 	register_token(PAREN_CLOSED,match_paren_closed,	"')'", 				true);

// 	/** KEYWORDS AND LITERALS **/
// 	register_token(DEF, 		match_def, 			"'def'", 			true);
// 	register_token(AND, 		match_and, 			"'and'", 			true);
// 	register_token(OR, 			match_or, 			"'or'", 			true);
// 	register_token(NOT, 		match_not, 			"'not'", 			true);
// 	register_token(COMMA, 		match_comma, 		"','", 				true);
// 	register_token(DOT, 		match_dot, 			"'.'", 				true);
// 	register_token(IDENTIFIER, 	match_identifier, 	"IDENTIFIER", 		true);
// 	/**
// 	 * INDENT and DEDENT are never matched in text, only
// 	 * generated by the lexer when matching INDENT FRAGMENT
// 	 */
// 	register_token(INDENT_FRAG, match_indent_frag, 	"INDENT FRAGMENT",	false);
// 	register_token(INDENT,		match_always_fail,	"INDENT",			false);
// 	register_token(DEDENT,		match_always_fail,	"DEDENT",			false);
// }

// int squid_lexer::compute_indent_level(str_iter iter, str_iter end)
// {
// 	int level = 0;
// 	iter = iter.match("\n");
// 	while(iter.valid() && iter <= end)
// 	{

// 		iter = iter.match(space_indent) | iter.match("\t");
// 		if(iter.valid())
// 			level++;
// 		else
// 			report_warning("Malformed indentation detected", get_position());
// 	}
// 	return level;
// }

// token squid_lexer::indent_lookahead()
// {
// 	if(!tokens_ahead.empty())
// 	{
// 		token ahead_token = tokens_ahead.front();
// 		if(ahead_token.type == INDENT || 
// 		   ahead_token.type == DEDENT || 
// 		   ahead_token.type == INDENT_UNCHANGED)
// 		{
// 			return ahead_token;
// 		}
// 		else
// 		{
// 			rollback();
// 		}
// 	}

// 	token indent_token;
// 	if(match_expected_token(indent_token, INDENT_FRAG, false))
// 	{
// 		int level = compute_indent_level(
// 			indent_token.text.get_start_iter(),
// 			indent_token.text.get_end_iter());
// 		int delta_indent = level - indent_level;
// 		tokens_ahead.clear();

// 		if(delta_indent > 0) //Code is indented one or more levels
// 		{
// 			tokens_ahead.push_back(token(INDENT, indent_token.text, indent_token.position));
// 			return tokens_ahead.front();
// 		}
// 		else if(delta_indent < 0) //Code is dedented one or more levels
// 		{
// 			for(int i = 0; i < (-delta_indent); ++i)
// 			{
// 				tokens_ahead.push_back(token(DEDENT, indent_token.text, indent_token.position));
// 			}
// 			return tokens_ahead.front();
// 		}
// 		else
// 		{
// 			tokens_ahead.push_back(token(INDENT_UNCHANGED, indent_token.text, indent_token.position));
// 			return tokens_ahead.front();
// 		}
// 	}
// 	else
// 	{
// 		return look_ahead(0);
// 	}
// }


// //FIXME: BROKEN, DEPRECATED
// bool squid_lexer::try_consume_indent_token(token_type type)
// {
// 	token indent_token;
// 	if(!tokens_ahead.empty() && tokens_ahead.front().type == type)
// 	{
// 		tokens_ahead.pop_front();
// 		return true;
// 	}
// 	if(try_consume(indent_token, INDENT_FRAG, false))
// 	{
// 		int level = compute_indent_level(
// 			indent_token.text.get_start_iter(),
// 			indent_token.text.get_end_iter());
// 		int delta_indent = level - indent_level;

// 		if(delta_indent > 0 && type == INDENT) //Code is indented one or more levels
// 		{
// 			/**
// 			 * Can only consume a single INDENT token in a row, so multiple INDENTS
// 			 * are collapsed into a single one.
// 			 */
// 			indent_level++;
// 			return true;
// 		}
// 		else if(delta_indent < 0 && type == DEDENT) //Code is dedented one or more levels
// 		{
// 			/**
// 			 * Consumes the first dedent, pushes the rest to tokens_ahead.
// 			 */
// 			indent_level += delta_indent;
// 			for(int i = 1; i < (-delta_indent); ++i)
// 			{
// 				tokens_ahead.push_front(token(DEDENT, string(), get_position()));
// 			}
// 			return true;
// 		}
// 		else if(delta_indent == 0 && type == INDENT_UNCHANGED)
// 		{
// 			return true;
// 		}
// 		else //Indentation level hasn't changed or indentation doesn't match type
// 		{
// 			return false;
// 		}
// 	}
// 	return false;
// }

// void squid_lexer::consume_indent_token(token_type type)
// {
// 	token t = indent_lookahead();
// 	if(t.type == type)
// 	{
// 		tokens_ahead.pop_front();
// 		if(type == INDENT)
// 		{
// 			indent_level++;
// 		}
// 		else if(type == DEDENT)
// 		{
// 			indent_level--;
// 		}
// 	}
// 	else
// 	{
// 		if(type == INDENT)
// 			throw lexer_exception("Expected indented block.", current);
// 		else if(type == DEDENT)
// 			throw lexer_exception("Expected dedented block.", current);
// 		else
// 			throw lexer_exception("Expected indentation not to change.", current);
// 	}
// }


// // void squid_lexer::consume_indent_token(token_type type)
// // {
// // 	if(!try_consume_indent_token(type))
// // 	{
// // 		if(type == INDENT)
// // 			throw lexer_exception("Expected indented block.", current);
// // 		else
// // 			throw lexer_exception("Expected dedented block.", current);
// // 	}
// // }


}